ID,Result,Loop Count,Chat History,Valid Answer
KickerOperation.rst_0,False,10,"[{'answer': '{\n  ""code"": ""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""\n}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}]",
KickerOperation.rst_1,False,10,"[{'answer': '{\n  ""code"": ""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""\n}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event< EvAction > {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine< Machine, i0 > {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state< i0, Machine > {\\n        typedef sc::transition< EvAction, SGoToBall > reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state< SGoToBall, Machine > {\\n        typedef sc::transition< EvAction, SShoot > reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state< SShoot, Machine > {\\n        typedef sc::custom_reaction< EvAction > reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state< SDribble, Machine > {\\n        typedef sc::transition< EvAction, f0 > reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination< f0 > {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isKickable();\\nbool canShootToGoal();\\n\\nclass StateMachine {\\npublic:\\n    struct EvAction : sc::event<EvAction> {};\\n\\n    struct i0;\\n    struct f0;\\n    struct SGoToBall;\\n    struct SShoot;\\n    struct SDribble;\\n\\n    struct Machine : sc::state_machine<Machine, i0> {\\n        rcsc::PlayerAgent* agent;\\n        bool canShoot;\\n        bool isKickable;\\n\\n        Machine(rcsc::PlayerAgent* agent) : agent(agent), canShoot(false), isKickable(false) {}\\n    };\\n\\n    struct i0 : sc::state<i0, Machine> {\\n        typedef sc::transition<EvAction, SGoToBall> reactions;\\n        i0(my_context ctx) : my_base(ctx) {}\\n    };\\n\\n    struct SGoToBall : sc::state<SGoToBall, Machine> {\\n        typedef sc::transition<EvAction, SShoot> reactions;\\n        SGoToBall(my_context ctx) : my_base(ctx) {\\n            context<Machine>().isKickable = isKickable();\\n            if (!context<Machine>().isKickable) {\\n                context<Machine>().agent->doMove(context<Machine>().agent->world().ball().pos());\\n            }\\n        }\\n    };\\n\\n    struct SShoot : sc::state<SShoot, Machine> {\\n        typedef sc::custom_reaction<EvAction> reactions;\\n        SShoot(my_context ctx) : my_base(ctx) {\\n            context<Machine>().canShoot = canShootToGoal();\\n        }\\n\\n        sc::result react(const EvAction&) {\\n            if (context<Machine>().canShoot) {\\n                context<Machine>().agent->doShoot();\\n                return transit<f0>();\\n            } else {\\n                return transit<SDribble>();\\n            }\\n        }\\n    };\\n\\n    struct SDribble : sc::state<SDribble, Machine> {\\n        typedef sc::transition<EvAction, f0> reactions;\\n        SDribble(my_context ctx) : my_base(ctx) {\\n            context<Machine>().agent->doDribble();\\n        }\\n    };\\n\\n    struct f0 : sc::termination<f0> {};\\n\\n    void execute(rcsc::PlayerAgent* agent) {\\n        Machine machine(agent);\\n        machine.initiate();\\n        while (!machine.terminated()) {\\n            machine.process_event(EvAction());\\n        }\\n    }\\n};""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}]",
GoalieOperation.rst_0,False,10,"[{'answer': '{\n  ""code"": ""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""\n}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}]",
GoalieOperation.rst_1,False,10,"[{'answer': '{\n  ""code"": ""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""\n}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}, {'answer': '{""code"":""#include \\""rcsc/geom/vector_2d.h\\""\\n#include <boost/statechart/custom_reaction.hpp>\\n#include <boost/statechart/termination.hpp>\\n#include <boost/statechart/event.hpp>\\n#include <boost/statechart/result.hpp>\\n#include <boost/statechart/simple_state.hpp>\\n#include <boost/statechart/state.hpp>\\n#include <boost/statechart/state_machine.hpp>\\n#include <boost/statechart/transition.hpp>\\n#include <rcsc/player/soccer_action.h>\\n#include <rcsc/player/world_model.h>\\n#include <rcsc/player/player_agent.h>\\n\\nnamespace sc = boost::statechart;\\n\\nbool isCatchable(rcsc::PlayerAgent *agent);\\nbool isInOurPenaltyArea(rcsc::PlayerAgent *agent);\\nbool checkTackle(double prob);\\n\\nstruct EvProcess : sc::event<EvProcess> {};\\n\\nclass StateMachine : public sc::state_machine<StateMachine, struct i0> {\\npublic:\\n    bool insideGoalieArea;\\n    bool catchable;\\n    bool isTacklePossible;\\n    rcsc::PlayerAgent *agent;\\n};\\n\\nstruct i0 : sc::state<i0, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    i0(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        return transit<SdoCatch>();\\n    }\\n};\\n\\nstruct SdoCatch : sc::state<SdoCatch, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoCatch(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.insideGoalieArea = isInOurPenaltyArea(machine.agent);\\n        machine.catchable = isCatchable(machine.agent);\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.catchable && machine.insideGoalieArea) {\\n            machine.agent->doShoot();\\n            return transit<f0>();\\n        }\\n        return transit<SClearBall>();\\n    }\\n};\\n\\nstruct SClearBall : sc::state<SClearBall, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SClearBall(my_context ctx) : my_base(ctx) {}\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.agent->world().self().isKickable()) {\\n            machine.agent->doTackle();\\n            return transit<f0>();\\n        }\\n        return transit<SdoTackle>();\\n    }\\n};\\n\\nstruct SdoTackle : sc::state<SdoTackle, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    SdoTackle(my_context ctx) : my_base(ctx) {\\n        StateMachine &machine = context<StateMachine>();\\n        machine.isTacklePossible = checkTackle(machine.agent->world().self().tackleProbability());\\n    }\\n    sc::result react(const EvProcess &) {\\n        StateMachine &machine = context<StateMachine>();\\n        if (machine.isTacklePossible) {\\n            machine.agent->doCatch();\\n            return transit<f0>();\\n        }\\n        return transit<doMove>();\\n    }\\n};\\n\\nstruct doMove : sc::state<doMove, StateMachine> {\\n    typedef sc::custom_reaction<EvProcess> reactions;\\n    doMove(my_context ctx) : my_base(ctx) {\\n        context<StateMachine>().agent->doMove();\\n    }\\n    sc::result react(const EvProcess &) {\\n        return transit<f0>();\\n    }\\n};\\n\\nstruct f0 : sc::state<f0, StateMachine> {\\n    typedef sc::termination reactions;\\n    f0(my_context ctx) : my_base(ctx) {}\\n};\\n\\nint main() {\\n    rcsc::PlayerAgent agent;\\n    StateMachine sm;\\n    sm.agent = &agent;\\n    sm.initiate();\\n    sm.process_event(EvProcess());\\n    return 0;\\n}""}', 'error': ""module 'src.errors' has no attribute 'CompilationError'""}]",
